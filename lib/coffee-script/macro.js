// Generated by CoffeeScript 1.6.3
var __hasProp = {}.hasOwnProperty;

(function() {
  var callFunc, cloneNode, createObject, evalAlias, fs, getFunc, nodeTypes, throwSyntaxError;
  fs = require('fs');
  throwSyntaxError = require('./helpers').throwSyntaxError;
  nodeTypes = require('./nodes');
  createObject = Object.create;
  if (typeof createObject !== 'function') {
    createObject = function(proto) {
      var f;
      f = function() {};
      f.prototype = proto;
      return f;
    };
  }
  cloneNode = function(src) {
    var key, ret, val, x;
    if (typeof src !== 'object' || src === null) {
      return src;
    }
    if (src instanceof Array) {
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = src.length; _i < _len; _i++) {
          x = src[_i];
          _results.push(cloneNode(x));
        }
        return _results;
      })();
    }
    ret = createObject((typeof Object.getPrototypeOf === "function" ? Object.getPrototypeOf(src) : void 0) || src.__proto__ || src.constructor.prototype);
    for (key in src) {
      if (!__hasProp.call(src, key)) continue;
      val = src[key];
      ret[key] = cloneNode(val);
    }
    return ret;
  };
  evalAlias = eval;
  getFunc = function(func) {
    return evalAlias("(" + func.compile({
      indent: ""
    }) + ")");
  };
  callFunc = function(func, node, context, args) {
    var e;
    if (args == null) {
      args = [];
    }
    try {
      return func.apply(context, args);
    } catch (_error) {
      e = _error;
      return throwSyntaxError("exception in macro: " + (e.stack || e) + "\n\n" + func + "\n", node.locationData);
    }
  };
  return exports.expand = function(ast, csToNodes) {
    var context, getCalleeName, helpers, k, v;
    context = {};
    helpers = {
      require: require,
      nodeToVal: function(node) {
        if (node) {
          return callFunc(getFunc(new this.Code([], new this.Block([node]))), node, context);
        }
      },
      nodeToId: function(node) {
        var _ref;
        if (node.base instanceof nodeTypes.Literal && node.isAssignable() && !((_ref = node.properties) != null ? _ref.length : void 0)) {
          return node.base.value;
        }
      },
      csToNode: function(code, filename) {
        return csToNodes(code, {
          filename: filename
        });
      },
      jsToNode: function(code) {
        return new nodeTypes.Literal(code || "void 0");
      },
      valToNode: function(expr) {
        return this.jsToNode(JSON.stringify(expr));
      },
      fileToNode: function(filename, lang) {
        var code;
        code = fs.readFileSync(filename, 'utf8');
        if (code.charCodeAt(0) === 0xFEFF) {
          code = code.substr(1);
        }
        if (lang === 'js' || (!lang && filename.match(/\.js$/))) {
          return this.jsToNode(code);
        } else {
          return this.csToNode(code, filename);
        }
      },
      bodyNodes: []
    };
    for (k in nodeTypes) {
      v = nodeTypes[k];
      helpers[k] = v;
    }
    root.macro = helpers;
    getCalleeName = function(node) {
      var name, prop, _i, _len, _ref, _ref1, _ref2, _ref3;
      if (node instanceof nodeTypes.Call && (name = (_ref = node.variable) != null ? (_ref1 = _ref.base) != null ? _ref1.value : void 0 : void 0)) {
        _ref2 = node.variable.properties;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          prop = _ref2[_i];
          name += '.' + (prop != null ? (_ref3 = prop.name) != null ? _ref3.value : void 0 : void 0);
        }
        return name;
      }
    };
    helpers.macros = {
      "macro": function(arg) {
        var name, res;
        if (arguments.length === 1) {
          if (arg instanceof nodeTypes.Code) {
            res = callFunc(getFunc(arg), arg, context);
            return (res instanceof nodeTypes.Base ? res : false);
          }
          if ((name = getCalleeName(arg)) && arg.args.length === 1 && arg.args[0] instanceof nodeTypes.Code) {
            helpers.macros[name] = getFunc(arg.args[0]);
            return false;
          }
        }
        throw new Error("invalid use of 'macro'");
      },
      "macro.codeToNode": function(func) {
        var num;
        if (!(func instanceof helpers.Code) || func.params.length) {
          throw new Error('macro.codeToNode expects a function (without arguments)');
        }
        num = helpers.bodyNodes.length;
        helpers.bodyNodes[num] = func.body;
        return helpers.jsToNode("macro.bodyNodes[" + num + "]");
      }
    };
    return nodeTypes.walk(ast, function(n) {
      var arg, func, name, res;
      if ((name = getCalleeName(n)) && (func = helpers.macros[name])) {
        res = callFunc(func, n, context, (function() {
          var _i, _len, _ref, _results;
          _ref = n.args;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            arg = _ref[_i];
            _results.push(cloneNode(arg));
          }
          return _results;
        })());
        return (res instanceof nodeTypes.Base ? res : false);
      }
    });
  };
})();
