// Generated by CoffeeScript 1.6.3
  var __hasProp = {}.hasOwnProperty;

  (function() {
    var cloneNode, createObject, evalAlias, fs;
    fs = require('fs');
    createObject = Object.create;
    if (typeof createObject !== 'function') {
      createObject = function(proto) {
        var f;
        f = function() {};
        f.prototype = proto;
        return f;
      };
    }
    cloneNode = function(src) {
      var key, ret, val, x;
      if (typeof src !== 'object' || src === null) {
        return src;
      }
      if (src instanceof Array) {
        return (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = src.length; _i < _len; _i++) {
            x = src[_i];
            _results.push(cloneNode(x));
          }
          return _results;
        })();
      }
      ret = createObject((typeof Object.getPrototypeOf === "function" ? Object.getPrototypeOf(src) : void 0) || src.__proto__ || src.constructor.prototype);
      for (key in src) {
        if (!__hasProp.call(src, key)) continue;
        val = src[key];
        ret[key] = cloneNode(val);
      }
      return ret;
    };
    evalAlias = eval;
    return exports.expand = function(ast, lexer, parser, options) {
      var k, macros, nodeTypes, utils, v, walkNodes;
      nodeTypes = parser.yy;
      walkNodes = function(node, visit) {
        var child, i, item, name, res, _i, _len, _ref;
        if (!node.children) {
          return;
        }
        _ref = node.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          name = _ref[_i];
          if (!(child = node[name])) {
            continue;
          }
          if (child instanceof Array) {
            i = 0;
            while (item = child[i++]) {
              res = visit(item);
              if (res) {
                child[--i] = res;
              } else if (res === false) {
                child.splice(--i, 1);
              } else {
                walkNodes(item, visit);
              }
            }
          } else {
            while ((res = visit(child))) {
              child = node[name] = res;
            }
            if (res === false) {
              node[name] = new nodeTypes.Undefined();
            } else {
              walkNodes(child, visit);
            }
          }
        }
        return node;
      };
      utils = {
        nodeToJs: function(node) {
          return node.compile({
            indent: ''
          });
        },
        nodeToVal: function(node) {
          return evalAlias('(' + this.nodeToJs(node) + ')');
        },
        nodeToId: function(node) {
          var _ref;
          if (node.base instanceof nodeTypes.Literal && node.isAssignable() && !((_ref = node.properties) != null ? _ref.length : void 0)) {
            return node.base.value;
          }
        },
        csToNode: function(code, filename) {
          return parser.parse(lexer.tokenize(code, {
            filename: filename
          }));
        },
        jsToNode: function(code) {
          return new nodeTypes.Literal(code || "void 0");
        },
        valToNode: function(expr) {
          return this.jsToNode(JSON.stringify(expr));
        },
        fileToNode: function(filename, lang) {
          var code;
          code = fs.readFileSync(filename, 'utf8');
          if (code.charCodeAt(0) === 0xFEFF) {
            code = code.substr(1);
          }
          if (lang === 'js' || (!lang && filename.match(/\.js$/))) {
            return this.jsToNode(code);
          } else {
            return this.csToNode(code, filename);
          }
        },
        substitute: function(node, replacements) {
          return walkNodes(cloneNode(node), function(n) {
            var i, ss, type, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
            _ref = ['index', 'name', 'source'];
            for (type = _i = 0, _len = _ref.length; _i < _len; type = ++_i) {
              i = _ref[type];
              if ((i || (n.source != null)) && (ss = (_ref1 = n[type]) != null ? _ref1.value : void 0) && (ss = replacements[ss])) {
                n[type].value = ss;
              }
            }
            if ((ss = ((_ref2 = n.variable) != null ? (_ref3 = _ref2.base) != null ? _ref3.value : void 0 : void 0) || ((_ref4 = n.base) != null ? _ref4.value : void 0)) && ((ss = replacements[ss]) != null)) {
              return ss;
            }
          });
        }
      };
      for (k in nodeTypes) {
        v = nodeTypes[k];
        utils[k] = v;
      }
      macros = {};
      return walkNodes(ast, function(n) {
        var arg, func, funcNode, m, name, res, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        if (options.filename && typeof n.locationData === 'object' && !n.locationData.file) {
          n.locationData.file = options.filename;
        }
        name = (_ref = n.variable) != null ? (_ref1 = _ref.base) != null ? _ref1.value : void 0 : void 0;
        if (name === 'macro' && ((_ref2 = n.args) != null ? _ref2.length : void 0) === 1) {
          if ((m = n.args[0]).body) {
            res = new Function([], "return " + m.compile({
              indent: ""
            }))().call(utils);
            return (res instanceof nodeTypes.Base ? res : false);
          }
          if ((name = (_ref3 = m.variable) != null ? (_ref4 = _ref3.base) != null ? _ref4.value : void 0 : void 0) && ((_ref5 = m.args) != null ? _ref5.length : void 0) === 1 && (funcNode = m.args[0]).body) {
            macros[name] = new Function([], "return " + funcNode.compile({
              indent: ""
            }))();
            return false;
          }
        }
        if ((func = macros[name]) && (((_ref6 = n.args) != null ? _ref6.length : void 0) != null)) {
          res = func.apply(utils, (function() {
            var _i, _len, _ref7, _results;
            _ref7 = n.args;
            _results = [];
            for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
              arg = _ref7[_i];
              _results.push(cloneNode(arg));
            }
            return _results;
          })());
          return (res instanceof nodeTypes.Base ? res : false);
        }
      });
    };
  })();
